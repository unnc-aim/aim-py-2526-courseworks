name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  ci:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.x"

      - name: Install tooling
        run: |
          python -m pip install --upgrade pip
          pip install autopep8 isort pytest

      - name: Run checks and write job summary
        shell: bash
        run: |
          set -eo pipefail

          # helper: append a titled block to the GitHub Actions job summary
          append_summary() {
            local title="$1"
            local status="$2"
            local file="$3"
            echo "## ${title}" >> "$GITHUB_STEP_SUMMARY"
            echo "- Status: ${status}" >> "$GITHUB_STEP_SUMMARY"
            if [ -n "${file}" ] && [ -s "${file}" ]; then
              echo '' >> "$GITHUB_STEP_SUMMARY"
              echo '```' >> "$GITHUB_STEP_SUMMARY"
              sed -n '1,500p' "${file}" >> "$GITHUB_STEP_SUMMARY"
              echo '```' >> "$GITHUB_STEP_SUMMARY"
            fi
            echo '' >> "$GITHUB_STEP_SUMMARY"
          }

          FAIL=0

          # Determine base ref for diff (works for push and PR). We'll try base SHA, then base branch, then origin/main
          if [ "${GITHUB_EVENT_NAME}" = "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            BASE_BRANCH_NAME="${{ github.event.pull_request.base.ref }}"
          else
            BASE_SHA="${{ github.event.before }}"
            BASE_BRANCH_NAME="${{ github.ref_name }}"
          fi

          # Try fetch by SHA first (fast), then by branch name, then fallback to origin/main
          if [ -n "${BASE_SHA}" ] && git fetch --no-tags --prune --depth=1 origin "${BASE_SHA}" >/dev/null 2>&1; then
            BASE_REF="${BASE_SHA}"
          elif [ -n "${BASE_BRANCH_NAME}" ] && git fetch --no-tags --prune --depth=1 origin "${BASE_BRANCH_NAME}" >/dev/null 2>&1; then
            BASE_REF="origin/${BASE_BRANCH_NAME}"
          else
            echo "Could not fetch base (${BASE_SHA:-<none>}, branch ${BASE_BRANCH_NAME:-<none>}); falling back to origin/main" >> "$GITHUB_STEP_SUMMARY"
            git fetch --no-tags --prune --depth=1 origin main >/dev/null 2>&1 || true
            BASE_REF="origin/main"
          fi

          CHANGED_FILES="$(git diff --name-only ${BASE_REF}...HEAD || true)"
          echo "### Changed files" >> "$GITHUB_STEP_SUMMARY"
          if [ -z "${CHANGED_FILES}" ]; then
            echo "No changed files detected; nothing to check." >> "$GITHUB_STEP_SUMMARY"
            exit 0
          else
            echo '```' >> "$GITHUB_STEP_SUMMARY"
            echo "${CHANGED_FILES}" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
          fi

          # Enforce that only main.py may be modified — fail immediately if any other file changed
          for f in ${CHANGED_FILES}; do
            if [ "${f}" != "main.py" ]; then
              echo "Only 'main.py' may be modified in this workflow" >> "$GITHUB_STEP_SUMMARY"
              echo "Workflow disallowed modification detected: ${f}" >&2
              exit 1
            fi
          done

          # Syntax check
          SYNTAX_OUT="/tmp/syntax.txt"
          python -m py_compile main.py 2>"${SYNTAX_OUT}" || true
          if [ -s "${SYNTAX_OUT}" ]; then
            append_summary "Syntax check" "❌ Failed" "${SYNTAX_OUT}"
            FAIL=1
          else
            append_summary "Syntax check" "✅ Passed"
            rm -f "${SYNTAX_OUT}"
          fi

          # autopep8 style diff
          APEP8_OUT="/tmp/autopep8.txt"
          autopep8 --diff main.py >"${APEP8_OUT}" || true
          if [ -s "${APEP8_OUT}" ]; then
            append_summary "autopep8 (style)" "❌ Issues" "${APEP8_OUT}"
            FAIL=1
          else
            append_summary "autopep8 (style)" "✅ Clean"
            rm -f "${APEP8_OUT}"
          fi

          # isort imports check
          ISORT_OUT="/tmp/isort.txt"
          isort --check --diff . >"${ISORT_OUT}" 2>&1 || true
          if [ -s "${ISORT_OUT}" ]; then
            append_summary "isort (imports)" "❌ Issues" "${ISORT_OUT}"
            FAIL=1
          else
            append_summary "isort (imports)" "✅ Clean"
            rm -f "${ISORT_OUT}"
          fi

          # pytest
          PYTEST_OUT="/tmp/pytest.txt"
          if [ -d tests ]; then
            pytest -q tests/ >"${PYTEST_OUT}" 2>&1 || true
            if [ -s "${PYTEST_OUT}" ] && grep -Eqi 'failed|error|FAILED|ERROR' "${PYTEST_OUT}" 2>/dev/null; then
              append_summary "pytest" "❌ See details" "${PYTEST_OUT}"
              FAIL=1
            else
              append_summary "pytest" "✅ Passed"
              rm -f "${PYTEST_OUT}"
            fi
          else
            append_summary "pytest" "⏭️ Skipped (no tests/ directory)"
          fi

          if [ "${FAIL}" -ne 0 ]; then
            echo "One or more checks failed. See job summary above for details." >> "$GITHUB_STEP_SUMMARY"
            exit 1
          else
            echo "All checks passed." >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi
